#ifndef COMPILER_H
#define COMPILER_H

#include "../parser/parser.h"
#include "../scanner/scanner.h"
#include "llvm/IR/Module.h"
#include <memory>
#include <string>
#include <vector>

/**
 * @brief A class to compile Niter code.
 * Runs code through the scanner, parser, type checker, and code generator.
 *
 */
class Compiler {
    // The names of the files to be compiled.
    std::vector<std::shared_ptr<std::string>> file_names;
    // The source code from each of the files
    std::vector<std::shared_ptr<std::string>> src_codes;
    // The target destination for the object file.
    std::shared_ptr<std::string> target_destination;
    // The target destination for the unoptimized, raw IR; empty if not specified.
    std::string ir_target_destination;
    // Whether to run the linker after compilation.
    bool run_linker = true;

    // The list of tokens generated by the scanner.
    std::vector<std::shared_ptr<Token>> tokens;
    // The list of statements generated by the parser.
    std::vector<std::shared_ptr<Stmt>> stmts;
    // The IR module generated by the code generator.
    std::unique_ptr<llvm::Module> ir_module;

public:
    Compiler() = default;

    /**
     * @brief Adds a file to the list of files to be compiled.
     *
     * @param file_name The name of the file to be compiled. The compiler won't actually read from this file, but error messages will use this name.
     * @param src_code The source code to be compiled.
     */
    void add_file(const std::string& file_name, const std::string& src_code);

    /**
     * @brief Adds a file to the list of files to be compiled.
     * This function will attempt to read the source code from the file specified.
     *
     * @param file_name The name of the file to be compiled. Path is relative to CWD.
     * @throws std::runtime_error If the file cannot be opened or read.
     */
    void add_file(const std::string& file_name);

    /**
     * @brief Set the target destination object.
     * If `run_linker` is true, `target` is expected to have no file extension.
     * If `run_linker` is false, `target` is expected to have an `.o` file extension.
     *
     * @param target The name of the target object file. Paths are relative to CWD.
     */
    void set_target_destination(const std::string& target) {
        target_destination = std::make_shared<std::string>(target);
    }

    /**
     * @brief Set the IR target destination object.
     * The IR will be written to this file before optimization.
     * It will be a text file; the extension `.ll` is recommended, but not required.
     *
     * @param target The name of the target IR file. Paths are relative to CWD.
     */
    void set_ir_target_destination(const std::string& target) {
        ir_target_destination = target;
    }

    /**
     * @brief Set whether to run the linker after compilation.
     * Default behavior is to run the linker.
     * This compiler uses `clang` to link the object file and automatically link the C standard library.
     *
     * @param run Set to true to run the linker, false to skip linking.
     */
    void set_run_linker(bool run) {
        run_linker = run;
    }

    /**
     * @brief Checks if the compiler has any input files.
     *
     * @return true If at least one input file has been successfully added.
     * @return false If no input files have been added.
     */
    bool has_input() {
        return file_names.size() > 0;
    }

    /**
     * @brief Compiles the source code under the configured settings.
     * Runs the source code through each stage of the compiler pipeline.
     * If any stage fails, the compilation is aborted.
     *
     * @return int 0 if the compilation was successful, 1 if there were errors.
     */
    int compile();
};

#endif // COMPILER_H
