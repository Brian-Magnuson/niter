#ifndef COMPILER_H
#define COMPILER_H

#include "../checker/global_checker.h"
#include "../checker/local_checker.h"
#include "../codegen/code_generator.h"
#include "../codegen/emitter.h"
#include "../codegen/optimizer.h"
#include "../logger/logger.h"
#include "../parser/parser.h"
#include "../scanner/scanner.h"
#include "llvm/IR/Module.h"
#include <fstream>
#include <memory>
#include <string>
#include <vector>

/**
 * @brief A class to compile Niter code.
 * Runs code through the scanner, parser, type checker, and code generator.
 *
 */
class Compiler {
    // The names of the files to be compiled.
    std::vector<std::shared_ptr<std::string>> file_names;
    // The source code from each of the files
    std::vector<std::shared_ptr<std::string>> src_codes;
    // The target destination for the object file.
    std::shared_ptr<std::string> target_destination;
    // The target destination for the unoptimized, raw IR; empty if not specified.
    std::string ir_target_destination;
    // Whether to run the linker after compilation.
    bool run_linker = true;

    // The list of tokens generated by the scanner.
    std::vector<std::shared_ptr<Token>> tokens;
    // The list of statements generated by the parser.
    std::vector<std::shared_ptr<Stmt>> stmts;
    // The IR module generated by the code generator.
    std::shared_ptr<llvm::Module> ir_module;

public:
    Compiler() = default;

    /**
     * @brief Adds a file to the list of files to be compiled.
     *
     * @param file_name The name of the file to be compiled. The compiler won't actually read from this file, but error messages will use this name.
     * @param src_code The source code to be compiled.
     */
    void add_file(const std::string& file_name, const std::string& src_code) {
        file_names.push_back(std::make_shared<std::string>(file_name));
        src_codes.push_back(std::make_shared<std::string>(src_code));
    }

    /**
     * @brief Adds a file to the list of files to be compiled.
     * This function will attempt to read the source code from the file specified.
     *
     * @param file_name The name of the file to be compiled. Path is relative to CWD.
     * @throws std::runtime_error If the file cannot be opened or read.
     */
    void add_file(const std::string& file_name) {
        std::ifstream file(file_name);
        if (!file.is_open()) {
            throw std::runtime_error("Could not open file: " + file_name);
        }
        std::string src_code((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
        if (file.bad()) {
            throw std::runtime_error("Error reading file: " + file_name);
        }
        add_file(file_name, src_code);
    }

    /**
     * @brief Set the target destination object.
     * If `run_linker` is true, `target` is expected to have no file extension.
     * If `run_linker` is false, `target` is expected to have an `.o` file extension.
     *
     * @param target The name of the target object file. Paths are relative to CWD.
     */
    void set_target_destination(const std::string& target) {
        target_destination = std::make_shared<std::string>(target);
    }

    /**
     * @brief Set the IR target destination object.
     * The IR will be written to this file before optimization.
     * It will be a text file; the extension `.ll` is recommended, but not required.
     *
     * @param target The name of the target IR file. Paths are relative to CWD.
     */
    void set_ir_target_destination(const std::string& target) {
        ir_target_destination = target;
    }

    /**
     * @brief Set whether to run the linker after compilation.
     * Default behavior is to run the linker.
     * This compiler uses `clang` to link the object file and automatically link the C standard library.
     *
     * @param run Set to true to run the linker, false to skip linking.
     */
    void set_run_linker(bool run) {
        run_linker = run;
    }

    /**
     * @brief Checks if the compiler has any input files.
     *
     * @return true If at least one input file has been successfully added.
     * @return false If no input files have been added.
     */
    bool has_input() {
        return file_names.size() > 0;
    }

    /**
     * @brief Compiles the source code under the configured settings.
     * Runs the source code through each stage of the compiler pipeline.
     * If any stage fails, the compilation is aborted.
     *
     * @return int 0 if the compilation was successful, 1 if there were errors.
     */
    int compile() {

        if (this->target_destination == nullptr) {
            if (this->run_linker) {
                this->target_destination = std::make_shared<std::string>("out");
            } else {
                this->target_destination = std::make_shared<std::string>("out.o");
            }
        }

        std::vector<std::function<bool()>> stages = {
            [this]() {
                Scanner scanner;
                for (size_t i = 0; i < this->file_names.size(); i++) {
                    scanner.scan_file(this->file_names[i], this->src_codes[i]);
                }
                this->tokens = scanner.get_tokens();
                return ErrorLogger::inst().get_errors().size() == 0;
            },
            [this]() {
                Parser parser;
                this->stmts = parser.parse(this->tokens);
                return ErrorLogger::inst().get_errors().size() == 0;
            },
            [this]() {
                GlobalChecker global_checker;
                global_checker.type_check(this->stmts);
                return ErrorLogger::inst().get_errors().size() == 0;
            },
            [this]() {
                LocalChecker local_checker;
                local_checker.type_check(this->stmts);
                return ErrorLogger::inst().get_errors().size() == 0;
            },
            [this]() {
                CodeGenerator codegen;
                this->ir_module = codegen.generate(this->stmts, this->ir_target_destination);
                return ErrorLogger::inst().get_errors().size() == 0 && this->ir_module != nullptr;
            },
            [this]() {
                Optimizer optimizer;
                optimizer.optimize(this->ir_module);
                return ErrorLogger::inst().get_errors().size() == 0;
            },
            [this]() {
                Emitter emitter;
                auto target = *(this->target_destination);
                if (this->run_linker) {
                    target += ".o";
                }
                emitter.emit(this->ir_module, target);
                return ErrorLogger::inst().get_errors().size() == 0;
            }
        };

        for (auto& stage : stages) {
            if (!stage()) {
                std::cerr << "Compiled with errors. Exiting..." << std::endl;
                return 1;
            }
        }

        if (this->run_linker) {
            std::string cmd = "clang -lm -o " + *(this->target_destination) + " " + *(this->target_destination) + ".o";
            int status = system(cmd.c_str());
            if (status != 0) {
                std::cerr << "Linking failed with exit code " << status << std::endl;
                return 1;
            } else {
                // Delete the object file after linking
                std::string rm_cmd = "rm " + *(this->target_destination) + ".o";
                system(rm_cmd.c_str());
            }
        }

        return 0;
    }
};

#endif // COMPILER_H
