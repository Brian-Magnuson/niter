#include "checker/global_checker.h"
#include "checker/local_checker.h"
#include "codegen/code_generator.h"
#include "codegen/emitter.h"
#include "codegen/optimizer.h"
#include "logger/logger.h"
#include "parser/parser.h"
#include "scanner/scanner.h"
#include "llvm/IR/Module.h"
#include <cstdlib>
#include <fstream>
#include <functional>
#include <iostream>
#include <memory>
#include <string>
#include <vector>

/**
 * @brief A struct to hold the state of the compiler.
 * Contains the names of the files to be compiled, the source code of the files, the tokens generated by the scanner, the statements generated by the parser, and the IR module generated by the code generator.
 *
 */
struct CompilerState {
    // The names of the files to be compiled.
    std::vector<std::shared_ptr<std::string>> file_names;
    // The source code from each of the files
    std::vector<std::shared_ptr<std::string>> src_codes;
    // The target destination for the object file.
    std::shared_ptr<std::string> target_destination;
    // The target destination for the unoptimized, raw IR; nullptr if not specified.
    std::string ir_target_destination;
    // Whether to run the linker after compilation.
    bool run_linker = true;
    // The list of tokens generated by the scanner.
    std::vector<std::shared_ptr<Token>> tokens;
    // The list of statements generated by the parser.
    std::vector<std::shared_ptr<Stmt>> stmts;
    // The IR module generated by the code generator.
    std::shared_ptr<llvm::Module> ir_module;
};

/**
 * @brief Runs the compiler stages in sequence.
 *
 * @param state The compiler state. Should be initialized with the source code and file names.
 * @return int 0 if the compilation was successful, 1 if there were errors.
 */
int compile(CompilerState& state) {
    std::vector<std::function<bool(CompilerState&)>> stages = {
        [](CompilerState& state) {
            Scanner scanner;
            for (size_t i = 0; i < state.file_names.size(); i++) {
                scanner.scan_file(state.file_names[i], state.src_codes[i]);
            }
            state.tokens = scanner.get_tokens();
            return ErrorLogger::inst().get_errors().size() == 0;
        },
        [](CompilerState& state) {
            Parser parser;
            state.stmts = parser.parse(state.tokens);
            return ErrorLogger::inst().get_errors().size() == 0;
        },
        [](CompilerState& state) {
            GlobalChecker global_checker;
            global_checker.type_check(state.stmts);
            return ErrorLogger::inst().get_errors().size() == 0;
        },
        [](CompilerState& state) {
            LocalChecker local_checker;
            local_checker.type_check(state.stmts);
            return ErrorLogger::inst().get_errors().size() == 0;
        },
        [](CompilerState& state) {
            CodeGenerator codegen;
            state.ir_module = codegen.generate(state.stmts, state.ir_target_destination);
            return ErrorLogger::inst().get_errors().size() == 0 && state.ir_module != nullptr;
        },
        [](CompilerState& state) {
            Optimizer optimizer;
            optimizer.optimize(state.ir_module);
            return ErrorLogger::inst().get_errors().size() == 0;
        },
        [](CompilerState& state) {
            Emitter emitter;
            auto target = *state.target_destination;
            if (state.run_linker) {
                target += ".o";
            }
            emitter.emit(state.ir_module, target);
            return ErrorLogger::inst().get_errors().size() == 0;
        }
    };

    for (auto& stage : stages) {
        if (!stage(state)) {
            std::cerr << "Compiled with errors. Exiting..." << std::endl;
            return 1;
        }
    }

    if (state.run_linker) {
        std::string cmd = "clang -lm -o " + *state.target_destination + " " + *state.target_destination + ".o";
        int status = system(cmd.c_str());
        if (status != 0) {
            std::cerr << "Linking failed with exit code " << status << std::endl;
            return 1;
        } else {
            // Delete the object file after linking
            std::string rm_cmd = "rm " + *state.target_destination + ".o";
            system(rm_cmd.c_str());
        }
    }

    return 0;
}

int main(int argc, char** argv) {
    if (argc <= 1) {
        std::cout << "Usage: niterc [-c] [-o output] [-dump-ir output] <source files>" << std::endl;
        return 2;
    }

    CompilerState state;

    for (int i = 1; i < argc; i++) {
        auto str = std::make_shared<std::string>(argv[i]);

        if (str->at(0) == '-') {
            if (*str == "-o") {
                if (state.target_destination != nullptr) {
                    std::cerr << "Multiple output files specified" << std::endl;
                    return 2;
                } else if (i + 1 < argc) {
                    i++;
                    auto output = std::make_shared<std::string>(argv[i]);
                    state.target_destination = output;
                } else {
                    std::cerr << "Expected output file after -o" << std::endl;
                    return 2;
                }
            } else if (*str == "-c") {
                state.run_linker = false;
            } else if (*str == "-dump-ir") {
                if (state.ir_target_destination != "") {
                    std::cerr << "Multiple IR output files specified" << std::endl;
                    return 2;
                } else if (i + 1 < argc) {
                    i++;
                    auto output = std::make_shared<std::string>(argv[i]);
                    state.ir_target_destination = *output;
                } else {
                    std::cerr << "Expected IR output file after -dump-ir" << std::endl;
                    return 2;
                }
            } else {
                std::cerr << "Unknown option: " << str << std::endl;
                return 2;
            }

            continue;
        }

        std::ifstream file(*str);
        if (!file.is_open()) {
            std::cerr << "Could not open file: " << *str << std::endl;
            return 3;
        }
        auto src = std::make_shared<std::string>((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
        file.close();

        state.file_names.push_back(str);
        state.src_codes.push_back(src);
    }

    if (state.file_names.empty()) {
        std::cerr << "No input files specified" << std::endl;
        return 2;
    }

    if (state.target_destination == nullptr) {
        if (state.run_linker) {
            state.target_destination = std::make_shared<std::string>("out");
        } else {
            state.target_destination = std::make_shared<std::string>("out.o");
        }
    }

    return compile(state);
}
